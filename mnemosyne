#!/bin/bash

# mnemosyne - CLI wrapper for Mnemosyne Cluster Management

CMD=$1
ARG=$2

PROJECT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$PROJECT_DIR"

show_help() {
    echo "Usage: ./mnemosyne <command> [args]"
    echo ""
    echo "Commands:"
    echo "  start           Start the cluster (docker compose up -d)"
    echo "  stop            Stop the cluster (docker compose down)"
    echo "  restart         Restart the cluster"
    echo "  mount <path>    Mount the WebDAV share to a local folder"
    echo "  unmount         Unmount the WebDAV share"
    echo "  update          Pull latest code (RESET hard) and rebuild"
    echo "  logs <service>  View logs (optional: service name)"
    echo ""
}

# Helper: Unmount safely
do_unmount() {
    # Check if a specific path was given via ARG (global), otherwise auto-detect
    TARGET="$1"
    
    if [ -n "$TARGET" ]; then
         if mount | grep -q "$TARGET"; then
             echo "Unmounting $TARGET..."
             if ! sudo umount "$TARGET"; then
                 echo "Standard unmount failed. Forcing lazy unmount..."
                 sudo umount -l "$TARGET"
             fi
         fi
    else
        # Auto-detect all mnemosyne mounts (Look for port 8080)
        MOUNT_POINTS=$(mount | grep "localhost:8080" | awk '{print $3}')
        for MP in $MOUNT_POINTS; do
            echo "Auto-unmounting: $MP"
            if ! sudo umount "$MP"; then
                echo "Standard unmount failed. Forcing lazy unmount ($MP)..."
                sudo umount -l "$MP"
            fi
        done
    fi
}

# Helper: Remount paths (passed as space-separated string)
do_remount() {
    MOUNTS="$1"
    for MP in $MOUNTS; do
        if [ -n "$MP" ]; then
            echo "Waiting for WebDAV service..."
            wait_for_port 8080
            
            echo "Restoring mount at $MP..."
            # Stability Fix: Mount Root (/) instead of /archive to avoid 405 errors
            sudo mount -t davfs -o uid=$(id -un),gid=$(id -gn),use_locks=0 http://localhost:8080/ "$MP"
        fi
    done
}

# Helper: Wait for a port to be open (up to 30s)
wait_for_port() {
    PORT=$1
    RETRIES=30
    while [ $RETRIES -gt 0 ]; do
        if nc -z 127.0.0.1 $PORT >/dev/null 2>&1; then
            return 0
        fi
        sleep 1
        RETRIES=$((RETRIES-1))
    done
    echo "Warning: Port $PORT did not open in time."
    return 1
}

case "$CMD" in
    start)
        echo "Starting Mnemosyne..."
        docker compose up -d --build --remove-orphans
        ;;
    stop)
        echo "Stopping Mnemosyne..."
        do_unmount
        docker compose down
        ;;
    restart)
        # Capture current mounts before we kill them
        DETECTED_MOUNTS=$(mount | grep "localhost:8080" | awk '{print $3}')
        
        echo "Restarting Mnemosyne..."
        do_unmount
        docker compose restart
        
        # Restore mounts
        do_remount "$DETECTED_MOUNTS"
        ;;
    mount)
        if [ -z "$ARG" ]; then
            echo "Error: details directory required."
            echo "Usage: ./mnemosyne mount /path/to/folder"
            exit 1
        fi
        
        # Check for davfs2
        if ! command -v mount.davfs &> /dev/null; then
            echo "Error: davfs2 not installed. Run: sudo apt install davfs2"
            exit 1
        fi

        echo "Creating mount point at $ARG..."
        sudo mkdir -p "$ARG"
        
        # Stability Fix: Removed aggressive ~/.davfs2/davfs2.conf generation.
        # We rely on CLI flags and default caching for better compatibility.
        
        echo "Mounting http://localhost:8080/ to $ARG..."
        wait_for_port 8080
        # Mount Root to avoid 405 errors on subpaths
        sudo mount -t davfs -o uid=$(id -un),gid=$(id -gn),use_locks=0 http://localhost:8080/ "$ARG"
        echo "Success! Mounted at $ARG"
        ;;
    unmount)
        do_unmount "$ARG"
        echo "Done."
        ;;
    update)
        echo "WARNING: This will RESET your local code to match the remote repository."
        echo "Your .env and data/ folder will be preserved."
        read -p "Are you sure? (y/N) " CONFIRM
        if [[ "$CONFIRM" =~ ^[Yy]$ ]]; then
            # Capture mounts
            DETECTED_MOUNTS=$(mount | grep "localhost:8080" | awk '{print $3}')
            
            echo "Unmounting before update..."
            do_unmount

            echo "Fetching latest code..."
            git fetch origin
            git reset --hard origin/master
            
            echo "Rebuilding containers..."
            docker compose up -d --build --remove-orphans
            
            # Restore mounts
            do_remount "$DETECTED_MOUNTS"
            
            echo "Update Complete."
        else
             echo "Update cancelled."
        fi
        ;;
    logs)
        if [ -z "$ARG" ]; then
            docker compose logs -f --tail=100
        else
            docker compose logs -f --tail=100 "$ARG"
        fi
        ;;
    *)
        show_help
        exit 1
        ;;
esac
